<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>  · hexo</title><meta name="description" content=" - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://blog.csdn.net/Yuzzzzzz" target="_blank" class="nav-list-link">CSDN</a></li><li class="nav-list-item"><a href="https://github.com/Qwindplate" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title"></h1><div class="post-info">Sep 12, 2019</div><div class="post-content"><h1 id="陈立杰后缀自动机讲稿笔记"><a href="#陈立杰后缀自动机讲稿笔记" class="headerlink" title="陈立杰后缀自动机讲稿笔记"></a>陈立杰后缀自动机讲稿笔记</h1><p>trans(s,ch) 当前状态为s，读入<strong><em>字符</em></strong>ch之后，所达到的状态</p>
<p>Cur = trans(s,str)</p>
<p>Reg(A)：自动机A能识别的字符串（从init开始识别到end）</p>
<p>Reg(s):从状态s开始能识别的字符串（s开始识别到end）</p>
<p>后缀自动机（suffix automaton/SAM）</p>
<p>定义：能识别S的所有后缀的自动机</p>
<p>SAM(x) =true 时，当且仅当x为S的后缀，后缀自动机也能用来识别S的所有子串</p>
<p>ST(str)表示trans(init,str)</p>
<p>suf为母串S的后缀集合</p>
<p>Fac为母串S的连续子串集合</p>
<p>从位置a开始的后缀为Suffix(a) </p>
<p>S[l,r)表示S中[l,r)这个区间构成的子串，下标从0开始。</p>
<p>a在S中的[l,r)位置出现 （这里的a是一个字符串，[l,r)可能不止一个） </p>
<p>计在母串S中a的后一个字符位置为$r_n$</p>
<p>Reg(ST(a))={$Suffix(r_1),Suffix(r_2),…,Suffix(r_n)$}</p>
<p>令Right(a)=${r_1,r_2,…,r_n}$,那么Reg(ST(a))就完全由Right(a)决定</p>
<p>一个状态s，由所有RIght集合是Right(s)的字符串组成</p>
<p>令r∈Right(s)，只要给定子串长度len，该子串就是S[r-len,r].</p>
<p>所有确定Right集合后，在给出一个长度就可以确定子串了</p>
<p>令s的区间为[Min(s),Max(s)]？？？？？</p>
<h1 id="要不换个博客来看看？"><a href="#要不换个博客来看看？" class="headerlink" title="要不换个博客来看看？"></a>要不换个博客来看看？</h1><p><del>学你🐎的理论，实践出真知</del></p>
<p><a href="https://www.luogu.org/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie" target="_blank" rel="external">链接</a></p>
<p>后缀自动机的性质（在该博客里用endpos表示Right<strong>集合</strong>，我觉得挺有道理的）</p>
<ul>
<li>如果两个子串的endpos相同，则其中子串一个必然为另一个的后缀</li>
<li>对任意两个子串t和p($len_t &lt;= len_p$),要么endpos(p)属于endpos(t),要么endpos(t) ∩ endpos(s) = $\varnothing $</li>
<li>对于endpos相同的子串，归为一个endpos等价类。对于任意一个等价类，将包含在其中的所以子串按长度从大到小排序，每个子串的长度均为上一个子串的长度减一，且为上一个子串的后缀</li>
<li>endpos等价类个数的级别为O(n)</li>
<li>一个类a中，由最长的子串，也有最短的子串，我们称最长子串的长度为len(a),最短子串长度为minlen(a)。 对于存在父子关系的两个类，设fa(a)表示类a的父亲(也是一个类)。则：len(fa(a))+1 = minlen(a)</li>
</ul>
<p>直接开始用叭(<del>学个机霸</del>）</p>
<p>1.insert</p>
<p>sam的构造是不断地向已经建好地sam中加入新地节点。last表示上一个被插入的节点，cnt表示sam中的节点数量，一开始只有一个起点的初始sam。last = cnt = 1；</p>
<p>接下来，假设要往sam里加入一个字符x</p>
<ul>
<li>新建节点np = ++cnt。新建节点，p=last，last=np </li>
<li>如果不存在ch[p][x] ,令ch[p][x] =np,p=fa[p]。重复此步骤</li>
</ul>
<blockquote>
<p>往上找找到第一个拥有x儿子的节点</p>
</blockquote>
<ul>
<li>如果到最后一个p都没有拥有儿子x，令fa[np]=1。退出过程。</li>
</ul>
<blockquote>
<p>如果都往上走都没有，则这个节点的父节点为初始点1</p>
</blockquote>
<ul>
<li>当ch[p][x]出现时,令q=ch[p][x]。如果len[q]==len[p]+1,令fa[np] = q。退出过程</li>
</ul>
<blockquote>
<p>如果满足这个条件，则np的父亲就为p</p>
</blockquote>
<ul>
<li><p>否则新建节点nq = ++cnt,将q的儿子都复制给nq，令len[nq] = len[p]+1。</p>
</li>
<li><p>令fa[nq] = fa[q],fa[q]=fa[np]=nq.</p>
</li>
<li>从p开始沿着后缀链接（p=fa[p]），将所有ch[p][x]==q的节点的ch[p][x]都替换成nq</li>
</ul>
<blockquote>
<p>p的儿子为q</p>
<p>新建一个节点nq，将q的儿子都复制给nq</p>
<p>nq的父节点设为p，np和q的父节点设为q</p>
<p>沿后缀链接将所有ch[px][x]==q的节点改为等于nq</p>
<p>相当于nq抢走了q的一切，而且让q和np认他为父亲，简直是杀人诛心</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> np = ++cnt,p=last;</div><div class="line">    len[np]=len[p]+<span class="number">1</span>,last = np;</div><div class="line">    <span class="keyword">while</span>(p&amp;&amp;!ch[p][x])</div><div class="line">        ch[p][x]=np,p=fa[p];</div><div class="line">    <span class="keyword">if</span>(!p)</div><div class="line">        fa[np] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> q = ch[p][x];</div><div class="line">        <span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>)</div><div class="line">            fa[np] = q;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> nq = ++cnt;</div><div class="line">            len[nq] = len[p]+<span class="number">1</span>;</div><div class="line">            memmove(ch[nq],ch[q],<span class="keyword">sizeof</span>(ch[nq]));</div><div class="line">            fa[nq] = fa[q];</div><div class="line">            fa[np] = fa[q] = nq;</div><div class="line">            <span class="keyword">while</span>(ch[p][x] == q)</div><div class="line">            &#123;</div><div class="line">            	ch[p][x] = nq;</div><div class="line">            	p = fa[p];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是sam就建好啦，艹。我也不知道为什么，等我知道了在回来补吧。</p>
<p>其实sam建出来的树相当于将节点个数压缩到O(n)的tire树，这颗tire树储存了一个字符串所有后缀，每条路劲都代表一个子串</p>
<p>right集合上面说过了就不说了</p>
<h3 id="据说是重点："><a href="#据说是重点：" class="headerlink" title="据说是重点："></a>据说是重点：</h3><p>节点x的后缀链接fa(x):right(x)$\subset$right(u),fa(x)是u中right最小的一个</p>
<p>后缀链接组成了一颗后缀链接树（not 后缀树）。后缀链接树的根为起点。若节点y的right集合包含了节点的right集合，则y再后缀链接树上是x的祖先</p>
<p>一个节点的right结合等于他再后缀链接树上的所有儿子的right集合的并集。而且儿子的right集合之间两两没有交集。</p>
<p>每个节点能表达的子串长度是一段连续的区间。</p>
<blockquote>
<p>比如aaabaab，节点b(4,7)表达的是b，ab，aab三个，他的儿子有两个(4)只能表示aaab （7）能表示baab，abaab，aabaab，aaabaaab。</p>
</blockquote>
<p>所有本质不同的子串数量等于$\sum$len(x)-len(fa(x))</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/09/12/8.9/" class="prev">PREV</a><a href="/2019/08/07/8.7/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>